"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = exports.Interaction = exports.determineExecutable = void 0;
exports.execCmd = execCmd;
exports.execInteractiveCmd = execInteractiveCmd;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("node:fs");
const node_child_process_1 = require("node:child_process");
const node_path_1 = require("node:path");
const node_util_1 = require("node:util");
const kit_1 = require("@salesforce/kit");
const ts_types_1 = require("@salesforce/ts-types");
const debug_1 = require("debug");
const shelljs = require("shelljs");
const shelljs_1 = require("shelljs");
const stripAnsi = require("strip-ansi");
const genUniqueString_1 = require("./genUniqueString");
const buildCmdOptions = (options) => {
    const defaults = {
        env: { ...process.env, ...options?.env },
        cwd: process.cwd(),
        timeout: kit_1.Duration.hours(1).milliseconds, // 1 hour
        silent: true,
        cli: 'inherit',
    };
    const shellOverride = kit_1.env.getString('TESTKIT_EXEC_SHELL');
    if (shellOverride) {
        defaults.shell = shellOverride;
    }
    return { ...defaults, ...options };
};
// Create a Duration instance from process.hrtime
const hrtimeToMillisDuration = (hrTime) => kit_1.Duration.milliseconds(hrTime[0] * kit_1.Duration.MILLIS_IN_SECONDS + hrTime[1] / 1e6);
// Add JSON output if json flag is set
const addJsonOutput = (cmd, result, file) => {
    if (cmd.includes('--json')) {
        try {
            return {
                ...result,
                jsonOutput: (0, kit_1.parseJson)(stripAnsi(fs.readFileSync(file, 'utf-8'))),
            };
        }
        catch (parseErr) {
            return { ...result, jsonError: parseErr };
        }
    }
    return result;
};
const getExitCodeError = (cmd, expectedCode, output) => {
    const errorDetails = output.stdout || output.stderr
        ? // return details if they exist
            `\nstdout=${output.stdout}\nstderr=${output.stderr}`
        : // or the raw string if there are no details
            `\n${output}`;
    return Error(`Unexpected exit code for command: ${cmd}. Expected: ${expectedCode} Actual: ${output.code} ${errorDetails}`);
};
/**
 * Determine the executable path for use by `execCmd`.
 *
 * If the cli is 'inherit', the executable preference order is:
 *    1. TESTKIT_EXECUTABLE_PATH env var
 *    2. `bin/run.js` (default)
 *
 * @returns The command string with CLI executable. E.g., `"node_modules/bin/sf org:create:user -a testuser1"`
 */
const determineExecutable = (cli = 'inherit') => {
    const debug = (0, debug_1.default)('testkit:determineExecutable');
    let bin;
    const root = Cache.getInstance().get('pluginDir') ?? process.cwd();
    switch (cli) {
        case 'inherit':
            bin =
                kit_1.env.getString('TESTKIT_EXECUTABLE_PATH') ??
                    (0, node_path_1.join)(root, 'bin', process.platform === 'win32' ? 'run.cmd' : 'run.js');
            break;
        case 'dev':
            bin =
                kit_1.env.getString('TESTKIT_EXECUTABLE_PATH') ??
                    (0, node_path_1.join)(root, 'bin', process.platform === 'win32' ? 'dev.cmd' : 'dev.js');
            break;
        case 'sfdx':
            bin = cli;
            break;
        case 'sf':
            bin = cli;
            break;
    }
    // Support plugins who still use bin/run instead of bin/run.js
    if (bin.endsWith('.js') && !fs.existsSync(bin))
        bin = bin.replace('.js', '');
    const which = shelljs.which(bin);
    let resolvedPath = (0, node_path_1.resolve)(bin);
    // If 'which' finds the path in the system path, use that.
    if (which) {
        resolvedPath = which;
    }
    else if (!fs.existsSync(bin)) {
        throw new Error(`Cannot find specified executable path: ${bin}`);
    }
    debug(`Resolved executable path: ${resolvedPath}`);
    debug(`Using executable path: ${bin}`);
    return bin;
};
exports.determineExecutable = determineExecutable;
const buildCmd = (cmdArgs, options) => {
    const bin = (0, exports.determineExecutable)(options?.cli);
    return `${bin} ${cmdArgs}`;
};
const execCmdSync = (cmd, options) => {
    const debug = (0, debug_1.default)('testkit:execCmd');
    // Add on the bin path
    cmd = buildCmd(cmd, options);
    const cmdOptions = buildCmdOptions(options);
    debug(`Running cmd: ${cmd}`);
    debug(`Cmd options: ${(0, node_util_1.inspect)(cmdOptions)}`);
    const stdoutFile = `${(0, genUniqueString_1.genUniqueString)('stdout')}.txt`;
    const stderrFile = `${(0, genUniqueString_1.genUniqueString)('stderr')}.txt`;
    const stdoutFileLocation = (0, node_path_1.join)(cmdOptions.cwd, stdoutFile);
    const stderrFileLocation = (0, node_path_1.join)(cmdOptions.cwd, stderrFile);
    const result = {
        shellOutput: new shelljs_1.ShellString(''),
        execCmdDuration: kit_1.Duration.seconds(0),
    };
    // Execute the command in a synchronous child process
    const startTime = process.hrtime();
    const code = shelljs.exec(`${cmd} 1> ${stdoutFile} 2> ${stderrFile} `, cmdOptions).code;
    // capture the output for both stdout and stderr
    result.shellOutput = new shelljs_1.ShellString(stripAnsi(fs.readFileSync(stdoutFileLocation, 'utf-8')));
    result.shellOutput.stdout = stripAnsi(result.shellOutput.stdout);
    const shellStringForStderr = new shelljs_1.ShellString(stripAnsi(fs.readFileSync(stderrFileLocation, 'utf-8')));
    // The ShellString constructor sets the argument as stdout, so we strip 'stdout' and set as stderr
    result.shellOutput.stderr = stripAnsi(shellStringForStderr.stdout);
    result.shellOutput.code = code;
    result.execCmdDuration = hrtimeToMillisDuration(process.hrtime(startTime));
    debug(`Command completed with exit code: ${result.shellOutput.code}`);
    if ((0, ts_types_1.isNumber)(cmdOptions.ensureExitCode) && result.shellOutput.code !== cmdOptions.ensureExitCode) {
        throw getExitCodeError(cmd, cmdOptions.ensureExitCode, result.shellOutput);
    }
    if (cmdOptions.ensureExitCode === 'nonZero' && result.shellOutput.code === 0) {
        throw getExitCodeError(cmd, cmdOptions.ensureExitCode, result.shellOutput);
    }
    const withJson = addJsonOutput(cmd, result, stdoutFileLocation);
    fs.rmSync(stderrFileLocation);
    fs.rmSync(stdoutFileLocation);
    return withJson;
};
const execCmdAsync = async (cmd, options) => {
    const debug = (0, debug_1.default)('testkit:execCmdAsync');
    // Add on the bin path
    cmd = buildCmd(cmd, options);
    return new Promise((resolve, reject) => {
        const cmdOptions = buildCmdOptions(options);
        debug(`Running cmd: ${cmd}`);
        debug(`Cmd options: ${(0, node_util_1.inspect)(cmdOptions)}`);
        // buildCmdOptions will always
        const stdoutFileLocation = (0, node_path_1.join)(cmdOptions.cwd, `${(0, genUniqueString_1.genUniqueString)('stdout')}.txt`);
        const stderrFileLocation = (0, node_path_1.join)(cmdOptions.cwd, `${(0, genUniqueString_1.genUniqueString)('stderr')}.txt`);
        const callback = (code, stdout, stderr) => {
            const execCmdDuration = hrtimeToMillisDuration(process.hrtime(startTime));
            debug(`Command completed with exit code: ${code}`);
            if ((0, ts_types_1.isNumber)(cmdOptions.ensureExitCode) && code !== cmdOptions.ensureExitCode) {
                const output = new shelljs_1.ShellString(stdout);
                output.code = code;
                output.stderr = stderr;
                reject(getExitCodeError(cmd, cmdOptions.ensureExitCode, output));
            }
            const result = {
                shellOutput: new shelljs_1.ShellString(fs.readFileSync(stdoutFileLocation, 'utf-8')),
                execCmdDuration,
            };
            result.shellOutput.code = code;
            if (code === 0) {
                result.shellOutput = new shelljs_1.ShellString(stripAnsi(fs.readFileSync(stdoutFileLocation, 'utf-8')));
                result.shellOutput.stdout = stripAnsi(result.shellOutput.stdout);
            }
            else {
                result.shellOutput = new shelljs_1.ShellString(stripAnsi(fs.readFileSync(stderrFileLocation, 'utf-8')));
                // The ShellString constructor sets the argument as stdout, so we strip 'stdout' and set as stderr
                result.shellOutput.stderr = stripAnsi(result.shellOutput.stdout);
            }
            const addJson = addJsonOutput(cmd, result, stdoutFileLocation);
            fs.rmSync(stdoutFileLocation);
            fs.rmSync(stderrFileLocation);
            resolve(addJson);
        };
        // Execute the command async in a child process
        const startTime = process.hrtime();
        shelljs.exec(`${cmd} 1> ${stdoutFileLocation} 2> ${stderrFileLocation}`, cmdOptions, callback);
    });
};
function execCmd(cmd, options) {
    if (options?.async) {
        return execCmdAsync(cmd, options);
    }
    else {
        return execCmdSync(cmd, options);
    }
}
function toString(arrOrString) {
    if (Array.isArray(arrOrString)) {
        return arrOrString.join('');
    }
    return arrOrString;
}
function toArray(arrOrString) {
    if (Array.isArray(arrOrString)) {
        return arrOrString;
    }
    return [arrOrString];
}
var Interaction;
(function (Interaction) {
    Interaction["DOWN"] = "\u001B[B";
    Interaction["UP"] = "\u001B[A";
    Interaction["ENTER"] = "\r";
    Interaction["SELECT"] = " ";
    Interaction["Yes"] = "Y\r";
    Interaction["No"] = "N\r";
    Interaction["BACKSPACE"] = "\b";
    Interaction["ALL"] = "a";
})(Interaction || (exports.Interaction = Interaction = {}));
/**
 * Execute an interactive command.
 *
 * @example
 * ```
 * import { TestSession, execInteractiveCmd, Interaction } from '@salesforce/cli-plugins-testkit';
 *
 * const result = await execInteractiveCmd(
 *    'dev generate plugin',
 *    {
 *      'internal Salesforce team': Interaction.Yes,
 *      'name of your new plugin': ['plugin-awesome', Interaction.ENTER],
 *      'description for your plugin': ['a description', Interaction.ENTER],
 *      'Select the existing "sf" commands you plan to extend': [
 *        Interaction.SELECT,
 *        Interaction.DOWN,
 *        Interaction.SELECT,
 *        Interaction.ENTER,
 *      ],
 *    },
 *    { cwd: session.dir, ensureExitCode: 0 }
 *  );
 * ```
 *
 * If your flag values included spaces (where you'd normally need quotes like `some:cmd --flag "value with spaces"`),
 * use an array of strings to represent the command ex: `['some:cmd', '--flag', 'value with spaces']`
 */
async function execInteractiveCmd(command, answers, options = {}) {
    const debug = (0, debug_1.default)('testkit:execInteractiveCmd');
    return new Promise((resolve, reject) => {
        if (typeof command === 'string' && command.includes('"')) {
            throw new Error('Use an array of strings to represent the command when it includes quotes, ex: ["some:cmd", "--flag", "value with spaces"]');
        }
        const bin = (0, exports.determineExecutable)(options?.cli).trim();
        const startTime = process.hrtime();
        const opts = process.platform === 'win32'
            ? { shell: true, cwd: process.cwd(), ...options }
            : { cwd: process.cwd(), ...options };
        const child = (0, node_child_process_1.spawn)(bin, Array.isArray(command) ? command : command.split(' '), opts);
        child.stdin.setDefaultEncoding('utf-8');
        const seen = new Set();
        const output = {
            stdout: [],
            stderr: [],
        };
        const scrollLimit = kit_1.env.getNumber('TESTKIT_SCROLL_LIMIT', 1000) ?? 1000;
        let scrollCount = 0;
        const handleData = (data, stream) => {
            if (scrollCount > scrollLimit) {
                reject(new Error(`Scroll limit of ${scrollLimit} reached`));
            }
            const current = data.toString();
            debug(`${stream}: ${current}`);
            output[stream].push(current);
            const matchingQuestion = Object.keys(answers)
                .filter((key) => !seen.has(key))
                .find((key) => new RegExp(key).test(current));
            if (!matchingQuestion)
                return;
            const answerString = toString(answers[matchingQuestion]);
            const answerArray = toArray(answers[matchingQuestion]);
            // If the answer includes a string that's NOT an Interactive enum value, then we need to scroll to it.
            const scrollTarget = answerArray.find((answer) => !Object.values(Interaction).includes(answer));
            const shouldScrollForAnswer = current.includes('❯') && scrollTarget;
            if (shouldScrollForAnswer) {
                // recent inquirer versions include a unicode character in the prompt that we need to strip out
                // it's something like a backspace or a backline character used to type over existing output
                // this generally removes all the "control" characters in the first section of unicode
                const regex = /(?<=❯\s)([\u0020-\u00d7ff]+)/g;
                const selected = (current.match(regex) ?? [''])[0].trim();
                if (selected === scrollTarget) {
                    seen.add(matchingQuestion);
                    child.stdin.write(Interaction.ENTER);
                }
                else {
                    scrollCount += 1;
                    child.stdin.write(Interaction.DOWN);
                }
            }
            else {
                seen.add(matchingQuestion);
                scrollCount = 0;
                child.stdin.write(answerString);
            }
        };
        child.stdout.on('data', (data) => handleData(data, 'stdout'));
        child.stderr.on('data', (data) => handleData(data, 'stderr'));
        child.on('close', (code) => {
            debug(`child process exited with code ${code}`);
            child.stdin.end();
            const result = {
                code,
                stdout: stripAnsi(output.stdout.join('\n')),
                stderr: stripAnsi(output.stderr.join('\n')),
                duration: hrtimeToMillisDuration(process.hrtime(startTime)),
            };
            if ((0, ts_types_1.isNumber)(options.ensureExitCode) && code !== options.ensureExitCode) {
                reject(getExitCodeError(Array.isArray(command) ? command.join(' ') : command, options.ensureExitCode, {
                    stdout: result.stdout,
                    stderr: result.stderr,
                    code: result.code,
                }));
            }
            resolve(result);
        });
    });
}
class Cache extends Map {
    static getInstance() {
        if (!Cache.instance) {
            Cache.instance = new Cache();
        }
        return Cache.instance;
    }
}
exports.Cache = Cache;
//# sourceMappingURL=execCmd.js.map