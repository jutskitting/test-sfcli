"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestProject = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("node:fs");
const path = require("node:path");
const node_os_1 = require("node:os");
const node_util_1 = require("node:util");
const debug_1 = require("debug");
const shell = require("shelljs");
const kit_1 = require("@salesforce/kit");
const genUniqueString_1 = require("./genUniqueString");
const zip_1 = require("./zip");
/**
 * A SFDX project for use with testing.  The project can be defined by:
 *   1. Copied from a project on the filesystem to a destination dir
 *   2. Cloned using a git url
 *   3. Created by name using the project:generate command
 *
 * The project will be copied/cloned/created to the provided destination dir
 * or the OS tmpdir by default.
 */
class TestProject {
    constructor(options) {
        this.shelljsExecOptions = {
            silent: true,
        };
        this.debug = (0, debug_1.debug)('testkit:project');
        this.debug(`Creating TestProject with options: ${(0, node_util_1.inspect)(options)}`);
        this.zipDir = zip_1.zipDir;
        this.createdDate = new Date();
        const destDir = options.destinationDir ?? (0, node_os_1.tmpdir)();
        const shellOverride = kit_1.env.getString('TESTKIT_EXEC_SHELL');
        if (shellOverride) {
            this.shelljsExecOptions.shell = shellOverride;
        }
        // Copy a dir containing a SFDX project to a dir for testing.
        if (options.sourceDir) {
            const rv = shell.cp('-r', options.sourceDir, destDir);
            if (rv.code !== 0) {
                throw new Error(`project copy failed with error:\n${rv.stderr}`);
            }
            this.dir = path.join(destDir, path.basename(options.sourceDir));
        }
        // Clone a git repo containing a SFDX project in a dir for testing.
        else if (options.gitClone) {
            // verify git is found
            if (!shell.which('git')) {
                throw new Error('git executable not found for creating a project from a git clone');
            }
            this.debug(`Cloning git repo: ${options.gitClone} to: ${destDir}`);
            const execOpts = { ...this.shelljsExecOptions, ...{ cwd: destDir } };
            const rv = shell.exec(`git clone ${options.gitClone}`, execOpts);
            if (rv.code !== 0) {
                throw new Error(`git clone failed with error:\n${rv.stderr}`);
            }
            // the git clone will fail if the destination dir is not empty, so after
            // a successful clone the only contents should be the cloned repo dir.
            const cloneDirName = fs.readdirSync(destDir)[0];
            this.dir = path.join(destDir, cloneDirName);
        }
        // Create a new project using the command.
        else {
            // verify sf is found
            if (!shell.which('sf')) {
                throw new Error('sf executable not found for creating a project using project:generate command');
            }
            const name = options.name ?? (0, genUniqueString_1.genUniqueString)('project_%s');
            const rv = shell.exec(`sf project:generate -n ${name} -d ${destDir}${options.apiVersion ? ` --api-version ${options.apiVersion}` : ''}`, this.shelljsExecOptions);
            if (rv.code !== 0) {
                throw new Error(`project:generate failed with error:\n${rv.stderr}`);
            }
            this.dir = path.join(destDir, name);
        }
        this.debug(`Created test project: ${this.dir}`);
    }
    /**
     * Zip the test project contents
     *
     * @name name of the zip file to create. Default is the project dirname.
     * @destDir The zip file will be written to this path. Default is `process.cwd()`.
     * @returns The created zip file path.
     */
    async zip(name, destDir) {
        name ??= `${path.basename(this.dir)}.zip`;
        destDir ??= path.dirname(this.dir);
        return this.zipDir({ name, sourceDir: this.dir, destDir });
    }
}
exports.TestProject = TestProject;
//# sourceMappingURL=testProject.js.map