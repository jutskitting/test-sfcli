"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestSession = exports.rmOptions = void 0;
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fs = require("node:fs");
const path = require("node:path");
const debug_1 = require("debug");
const kit_1 = require("@salesforce/kit");
const sinon_1 = require("sinon");
const shell = require("shelljs");
const stripAnsi = require("strip-ansi");
const genUniqueString_1 = require("./genUniqueString");
const zip_1 = require("./zip");
const testProject_1 = require("./testProject");
const hubAuth_1 = require("./hubAuth");
const execCmd_1 = require("./execCmd");
// exported for test assertions
exports.rmOptions = { recursive: true, force: true };
/**
 * Represents a test session, which is a unique location for non-unit test (nut)
 * artifacts such as a project and a mocked home dir.  It also provides easy
 * access to an org username created by a setup command, cwd stubbing, and a way to
 * zip up the test session.
 *
 * Create a TestSession instance with: `const testSession = TestSession.create(options)`
 *
 * Fine-grained control over certain test session details are provided by these
 * environment variables:
 *   TESTKIT_SESSION_DIR = Overrides the default directory for the test session
 *   TESTKIT_HOMEDIR = path to a home directory that the tests will use as a stub of os.homedir
 *   TESTKIT_ORG_USERNAME = an org username to use for test commands. tests will use this org rather than creating new orgs.
 *   TESTKIT_PROJECT_DIR = a SFDX project to use for testing. the tests will use this project directly.
 *   TESTKIT_SAVE_ARTIFACTS = prevents a test session from deleting orgs, projects, and test sessions.
 *   TESTKIT_ENABLE_ZIP = allows zipping the session dir when this is true
 *   TESTKIT_SETUP_RETRIES = number of times to retry the org creates after the initial attempt before throwing an error
 *   TESTKIT_SETUP_RETRIES_TIMEOUT = milliseconds to wait before the next retry of scratch org creations. Defaults to 5000
 *   TESTKIT_EXEC_SHELL = the shell to use for all testkit shell executions rather than the shelljs default.
 *
 *   TESTKIT_HUB_USERNAME = username of an existing hub (authenticated before creating a session)
 *   TESTKIT_JWT_CLIENT_ID = clientId of connected app for auth:jwt:grant
 *   TESTKIT_JWT_KEY = JWT key (not a filepath, the actual contents of the key)
 *   TESTKIT_HUB_INSTANCE = instance url for the hub.  Defaults to https://login.salesforce.com
 *   TESTKIT_AUTH_URL = auth url to be used with auth:sfdxurl:store
 */
class TestSession extends kit_1.AsyncOptionalCreatable {
    constructor(options = {}) {
        super(options ?? {});
        // this is stored on the class so that tests can set it to something much lower than default
        this.rmRetryConfig = { retries: 12, delay: 5000 };
        this.orgs = new Map();
        this.sandbox = (0, sinon_1.createSandbox)();
        this.shelljsExecOptions = {
            silent: true,
        };
        this.orgsAliases = ['default'];
        this.options = options ?? {};
        this.debug = (0, debug_1.debug)('testkit:session');
        this.zipDir = zip_1.zipDir;
        // Cache the current process.cwd() so that we can use it when resolving
        // the bin/run.js executable path. This is necessary because setting the
        // project option changes the process.cwd() to the project dir, which
        // doesn't have bin/run.js
        execCmd_1.Cache.getInstance().set('pluginDir', process.cwd());
        this.createdDate = new Date();
        this.id = (0, genUniqueString_1.genUniqueString)(`${this.createdDate.valueOf()}%s`);
        this.retries = kit_1.env.getNumber('TESTKIT_SETUP_RETRIES', this.options.retries ?? 0);
        const shellOverride = kit_1.env.getString('TESTKIT_EXEC_SHELL');
        if (shellOverride) {
            this.shelljsExecOptions.shell = shellOverride;
        }
        // Create the test session directory
        this.overriddenDir = kit_1.env.getString('TESTKIT_SESSION_DIR') ?? this.options.sessionDir;
        this.dir = this.overriddenDir ?? path.join(process.cwd(), `test_session_${this.id}`);
        fs.mkdirSync(this.dir, { recursive: true });
        // Setup a test project and stub process.cwd to be the project dir
        if (this.options.project) {
            let projectDir = kit_1.env.getString('TESTKIT_PROJECT_DIR');
            if (!projectDir) {
                this.project = new testProject_1.TestProject({ ...this.options.project, destinationDir: this.dir });
                projectDir = this.project.dir;
            }
            this.stubCwd(projectDir);
        }
        // Write the test session options used to create this session
        fs.writeFileSync(path.join(this.dir, 'testSessionOptions.json'), JSON.stringify(JSON.parse(JSON.stringify(this.options))));
        let authStrategy = this.options.devhubAuthStrategy === 'AUTO' ? (0, hubAuth_1.getAuthStrategy)() : this.options.devhubAuthStrategy ?? 'NONE';
        (0, hubAuth_1.transferExistingAuthToEnv)(authStrategy);
        authStrategy =
            this.options.devhubAuthStrategy === 'AUTO' ? (0, hubAuth_1.getAuthStrategy)() : this.options.devhubAuthStrategy ?? 'NONE';
        // Set the homedir used by this test, on the TestSession and the process
        process.env.USERPROFILE = process.env.HOME = this.homeDir = kit_1.env.getString('TESTKIT_HOMEDIR', this.dir);
        process.env.SF_USE_GENERIC_UNIX_KEYCHAIN = 'true';
        (0, hubAuth_1.testkitHubAuth)(this.homeDir, authStrategy);
        if (authStrategy !== 'NONE') {
            const config = shell.exec('sf config get target-dev-hub --json', this.shelljsExecOptions);
            const configResults = JSON.parse(stripAnsi(config.stdout));
            const usernameOrAlias = configResults.result.find((org) => org.name === 'target-dev-hub')?.value;
            if (usernameOrAlias) {
                const displayEnv = shell.exec(`sf org:display -o ${usernameOrAlias} --json`, this.shelljsExecOptions);
                const displayEnvResults = JSON.parse(stripAnsi(displayEnv.stdout));
                this.hubOrg = displayEnvResults.result;
            }
        }
    }
    /**
     * Get an existing test session created with the same options,
     * or create a new session if a match is not found.  This allows
     * sharing of test sessions between multiple test files.
     *
     * TODO: this needs to be implemented so that it works with
     *       parallel testing.  We need to read a testSessionOptions.json
     *       file and compare options, then return that session.
     *
     * public static get(options: TestSessionOptions = {}): TestSession {
     *   return sessions.get(options) ?? new TestSession(options);
     * }
     */
    /**
     * Stub process.cwd() to return the provided directory path.
     *
     * @param dir The directory path to set as the current working directory
     */
    stubCwd(dir) {
        if (this.cwdStub) {
            this.cwdStub.restore();
        }
        this.debug(`Stubbing process.cwd to: ${dir}`);
        this.cwdStub = this.sandbox.stub(process, 'cwd').returns(dir);
    }
    /**
     * Clean the test session by restoring the sandbox, deleting any setup
     * org created during the test, and deleting the test session dir.
     */
    async clean() {
        this.debug(`Cleaning test session: ${this.id}`);
        // Always restore the sandbox
        this.sandbox.restore();
        if (!kit_1.env.getBoolean('TESTKIT_SAVE_ARTIFACTS')) {
            // Delete the orgs created by the tests unless pointing to a specific org
            await this.deleteOrgs();
            // Delete the session dir
            await this.rmSessionDir();
        }
    }
    /**
     * Zip the contents of a test session directory if the TESTKIT_ENABLE_ZIP
     * env var is set.
     *
     * @name The name of the zip file to create. Default is the test session dirname with .zip extension.
     * @destDir The zip file will be written to this path. Default is `this.dir/..`.
     * @returns The created zip file path.
     */
    async zip(name, destDir) {
        if (kit_1.env.getBoolean('TESTKIT_ENABLE_ZIP')) {
            name ??= `${path.basename(this.dir)}.zip`;
            destDir ??= path.dirname(this.dir);
            return this.zipDir({ name, sourceDir: this.dir, destDir });
        }
    }
    async init() {
        // Run all setup commands
        await this.createOrgs(this.options.scratchOrgs);
        this.debug('Created testkit session:');
        this.debug(`  ID: ${this.id}`);
        this.debug(`  Created Date: ${this.createdDate}`);
        this.debug(`  Dir: ${this.dir}`);
        this.debug(`  Home Dir: ${this.homeDir}`);
        if (this.orgs.size > 0) {
            this.debug('  Orgs: ', this.orgs);
        }
        if (this.project) {
            this.debug(`  Project: ${this.project.dir}`);
        }
    }
    async deleteOrgs() {
        if (!kit_1.env.getString('TESTKIT_ORG_USERNAME') && this.orgs.size > 0) {
            for (const org of [...this.orgs.keys()]) {
                if (this.orgsAliases.includes(org))
                    continue;
                this.debug(`Deleting test org: ${org}`);
                const rv = shell.exec(`sf org:delete:scratch -o ${org} -p`, this.shelljsExecOptions);
                this.orgs.delete(org);
                if (rv.code !== 0) {
                    // Must still delete the session dir if org:delete fails
                    // eslint-disable-next-line no-await-in-loop
                    await this.rmSessionDir();
                    throw Error(`Deleting org ${org} failed due to: ${rv.stderr}`);
                }
                this.debug('Deleted org result=', rv.stdout);
            }
        }
    }
    async rmSessionDir() {
        // Delete the test session unless they overrode the test session dir
        if (this.overriddenDir) {
            return;
        }
        this.debug(`Deleting test session dir: ${this.dir}`);
        try {
            return await fs.promises.rm(this.dir, exports.rmOptions);
        }
        catch (e) {
            this.debug(`Error deleting test session dir: ${this.dir}`);
            this.debug(e);
        }
    }
    // Executes commands and keeps track of any orgs created.
    // Throws if any commands return a non-zero exitCode.
    async createOrgs(orgs = []) {
        if (orgs.length === 0)
            return;
        const dbug = (0, debug_1.debug)('testkit:createOrgs');
        const setup = () => {
            for (const org of orgs) {
                // Don't create orgs if we are supposed to reuse one from the env
                const orgUsername = kit_1.env.getString('TESTKIT_ORG_USERNAME');
                if (orgUsername) {
                    dbug(`Not creating a new org. Reusing TESTKIT_ORG_USERNAME of: ${orgUsername}`);
                    this.orgs.set(orgUsername, { username: orgUsername });
                    continue;
                }
                const executable = org.executable ?? 'sf';
                if (!shell.which(executable)) {
                    throw new Error(`${executable} executable not found for creating scratch orgs`);
                }
                let baseCmd = `sf org:create:scratch --json -y ${org.duration ?? '1'} -w ${org.wait ?? 60}`;
                if (org.config) {
                    baseCmd += ` -f ${org.config}`;
                }
                if (org.alias) {
                    baseCmd += ` -a ${org.alias}`;
                }
                if (org.setDefault) {
                    baseCmd += ' -d';
                }
                if (org.username) {
                    baseCmd += ` --username ${org.username}`;
                }
                if (org.edition) {
                    baseCmd += ` -e ${org.edition}`;
                }
                // explicitly disable tracking only if set to false.  True is the default on the command
                if (org.tracksSource === false) {
                    baseCmd += ' --no-track-source';
                }
                const rv = shell.exec(baseCmd, this.shelljsExecOptions);
                rv.stdout = stripAnsi(rv.stdout);
                rv.stderr = stripAnsi(rv.stderr);
                if (rv.code !== 0) {
                    throw Error(`${baseCmd} failed due to: ${rv.stdout}`);
                }
                dbug(`Output for ${baseCmd} is:\n${rv.stdout}`);
                const jsonOutput = (0, kit_1.parseJson)(rv.stdout);
                const username = jsonOutput.result.username;
                dbug(`Saving org username: ${username} from ${baseCmd}`);
                this.orgs.set(username, jsonOutput.result.authFields);
                if (org.setDefault) {
                    this.orgs.set('default', jsonOutput.result.authFields);
                }
                if (org.alias) {
                    this.orgsAliases.push(org.alias);
                    this.orgs.set(org.alias, jsonOutput.result.authFields);
                }
            }
        };
        let attempts = 0;
        let completed = false;
        const timeout = new kit_1.Duration(kit_1.env.getNumber('TESTKIT_SETUP_RETRIES_TIMEOUT') ?? 5000, kit_1.Duration.Unit.MILLISECONDS);
        while (!completed && attempts <= this.retries) {
            try {
                dbug(`Executing org create(s) (attempt ${attempts + 1} of ${this.retries + 1})`);
                setup();
                completed = true;
            }
            catch (err) {
                attempts += 1;
                if (attempts > this.retries) {
                    throw err;
                }
                dbug(`Setup failed. waiting ${timeout.seconds} seconds before next attempt...`);
                // eslint-disable-next-line no-await-in-loop
                await this.deleteOrgs();
                // eslint-disable-next-line no-await-in-loop
                await this.sleep(timeout);
            }
        }
    }
    // used for test spy/stub
    // eslint-disable-next-line class-methods-use-this
    async sleep(duration) {
        await (0, kit_1.sleep)(duration);
    }
}
exports.TestSession = TestSession;
//# sourceMappingURL=testSession.js.map